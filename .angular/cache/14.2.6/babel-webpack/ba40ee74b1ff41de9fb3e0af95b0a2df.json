{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { __awaiter } from 'tslib';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n  return new Promise((resolve, reject) => {\n    if (!indexedDB) {\n      reject('IndexedDB not available');\n    }\n\n    const request = indexedDB.open(dbName, version);\n    let db;\n\n    request.onsuccess = event => {\n      db = request.result;\n      resolve(db);\n    };\n\n    request.onerror = event => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = event => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\n\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n  if (!indexedDB) {\n    return;\n  }\n\n  const request = indexedDB.open(dbName, version);\n\n  request.onupgradeneeded = event => {\n    const database = event.target.result;\n    storeSchemas.forEach(storeSchema => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n        storeSchema.storeSchema.forEach(schema => {\n          objectStore.createIndex(schema.name, schema.keypath, schema.options);\n        });\n      }\n    });\n    const storeMigrations = migrationFactory && migrationFactory();\n\n    if (storeMigrations) {\n      Object.keys(storeMigrations).map(k => parseInt(k, 10)).filter(v => v > event.oldVersion).sort((a, b) => a - b).forEach(v => {\n        storeMigrations[v](database, request.transaction);\n      });\n    }\n\n    database.close();\n  };\n\n  request.onsuccess = e => {\n    e.target.result.close();\n  };\n}\n\nfunction DeleteObjectStore(dbName, version, storeName) {\n  if (!dbName || !version || !storeName) {\n    throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n  }\n\n  return new Observable(obs => {\n    try {\n      const newVersion = version + 1;\n      const request = indexedDB.open(dbName, newVersion);\n\n      request.onupgradeneeded = event => {\n        const database = event.target.result;\n        database.deleteObjectStore(storeName);\n        database.close();\n        console.log('onupgradeneeded');\n        obs.next(true);\n        obs.complete();\n      };\n\n      request.onerror = e => obs.error(e);\n    } catch (error) {\n      obs.error(error);\n    }\n  });\n}\n\nfunction validateStoreName(db, storeName) {\n  return db.objectStoreNames.contains(storeName);\n}\n\nfunction validateBeforeTransaction(db, storeName, reject) {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\n\nfunction createTransaction(db, options) {\n  const trans = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.onabort = options.abort;\n  return trans;\n}\n\nfunction optionsGenerator(type, storeName, reject, resolve) {\n  return {\n    storeName,\n    dbMode: type,\n    error: e => {\n      reject(e);\n    },\n    abort: e => {\n      reject(e);\n    }\n  };\n}\n\nvar DBMode = /*#__PURE__*/(() => {\n  (function (DBMode) {\n    DBMode[\"readonly\"] = \"readonly\";\n    DBMode[\"readwrite\"] = \"readwrite\";\n  })(DBMode || (DBMode = {}));\n\n  return DBMode;\n})();\nconst CONFIG_TOKEN = new InjectionToken(null);\nlet NgxIndexedDBService = /*#__PURE__*/(() => {\n  class NgxIndexedDBService {\n    constructor(dbConfig, platformId) {\n      this.dbConfig = dbConfig;\n      this.platformId = platformId;\n\n      if (!dbConfig.name) {\n        throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n      }\n\n      if (!dbConfig.version) {\n        throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n      }\n\n      this.isBrowser = isPlatformBrowser(this.platformId);\n\n      if (this.isBrowser) {\n        this.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n        CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n        openDatabase(this.indexedDB, dbConfig.name).then(db => {\n          if (db.version !== dbConfig.version) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n              console.warn(`Using latest version ${db.version}`);\n            }\n\n            this.dbConfig.version = db.version;\n          }\n        });\n      }\n    }\n    /**\n     * Allows to crate a new object store ad-hoc\n     * @param storeName The name of the store to be created\n     * @param migrationFactory The migration factory if exists\n     */\n\n\n    createObjectStore(storeSchema, migrationFactory) {\n      const storeSchemas = [storeSchema];\n      CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n    }\n    /**\n     * Adds new entry in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param value The entry to be added\n     * @param key The optional key for the entry\n     */\n\n\n    add(storeName, value, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n\n          request.onsuccess = evt => __awaiter(this, void 0, void 0, function* () {\n            const result = evt.target.result;\n            const getRequest = objectStore.get(result);\n\n            getRequest.onsuccess = event => {\n              obs.next(event.target.result);\n              obs.complete();\n            };\n          });\n        }).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Adds new entries in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param values The entries to be added containing optional key attribute\n     */\n\n\n    bulkAdd(storeName, values) {\n      const promises = new Promise((resolve, reject) => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n          const objectStore = transaction.objectStore(storeName);\n          const results = values.map(value => {\n            return new Promise((resolve1, reject1) => {\n              const key = value.key;\n              delete value.key;\n              const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n\n              request.onsuccess = evt => {\n                const result = evt.target.result;\n                resolve1(result);\n              };\n            });\n          });\n          resolve(Promise.all(results));\n        }).catch(reason => reject(reason));\n      });\n      return from(promises);\n    }\n    /**\n     * Delete entries in the store and returns current entries in the store\n     * @param storeName The name of the store to add the item\n     * @param keys The keys to be deleted\n     */\n\n\n    bulkDelete(storeName, keys) {\n      const promises = keys.map(key => {\n        return new Promise((resolve, reject) => {\n          openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n            const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n            const objectStore = transaction.objectStore(storeName);\n            objectStore.delete(key);\n\n            transaction.oncomplete = () => {\n              this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n                resolve(newValues);\n              });\n            };\n          }).catch(reason => reject(reason));\n        });\n      });\n      return from(Promise.all(promises));\n    }\n    /**\n     * Returns entry by key.\n     * @param storeName The name of the store to query\n     * @param key The entry key\n     */\n\n\n    getByKey(storeName, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.get(key);\n\n          request.onsuccess = event => {\n            obs.next(event.target.result);\n            obs.complete();\n          };\n\n          request.onerror = event => {\n            obs.error(event);\n          };\n        }).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Retrieve multiple entries in the store\n     * @param storeName The name of the store to retrieve the items\n     * @param keys The ids entries to be retrieve\n     */\n\n\n    bulkGet(storeName, keys) {\n      const observables = keys.map(key => this.getByKey(storeName, key));\n      return new Observable(obs => {\n        combineLatest(observables).subscribe(values => {\n          obs.next(values);\n          obs.complete();\n        });\n      });\n    }\n    /**\n     * Returns entry by id.\n     * @param storeName The name of the store to query\n     * @param id The entry id\n     */\n\n\n    getByID(storeName, id) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.get(id);\n\n          request.onsuccess = event => {\n            obs.next(event.target.result);\n          };\n        }).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Returns entry by index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param key The entry key.\n     */\n\n\n    getByIndex(storeName, indexName, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.get(key);\n\n          request.onsuccess = event => {\n            obs.next(event.target.result);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Return all elements from one store\n     * @param storeName The name of the store to select the items\n     */\n\n\n    getAll(storeName) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.getAll();\n\n          request.onerror = evt => {\n            obs.error(evt);\n          };\n\n          request.onsuccess = ({\n            target: {\n              result: ResultAll\n            }\n          }) => {\n            obs.next(ResultAll);\n            obs.complete();\n          };\n        }).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Adds or updates a record in store with the given value and key. Return all items present in the store\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     */\n\n\n    update(storeName, value) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.put(value);\n\n          request.onsuccess = evt => __awaiter(this, void 0, void 0, function* () {\n            const result = evt.target.result;\n            const getRequest = objectStore.get(result);\n\n            getRequest.onsuccess = event => {\n              obs.next(event.target.result);\n              obs.complete();\n            };\n          });\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns all items from the store after delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n\n\n    delete(storeName, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.delete(key);\n\n          transaction.oncomplete = () => {\n            this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n              obs.next(newValues);\n              obs.complete();\n            });\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns true from the store after a successful delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n\n\n    deleteByKey(storeName, key) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n\n          transaction.oncomplete = () => {\n            obs.next(true);\n            obs.complete();\n          };\n\n          objectStore.delete(key);\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns true if successfully delete all entries from the store.\n     * @param storeName The name of the store to have the entries deleted\n     */\n\n\n    clear(storeName) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.clear();\n\n          transaction.oncomplete = () => {\n            obs.next(true);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns true if successfully delete the DB.\n     */\n\n\n    deleteDatabase() {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => __awaiter(this, void 0, void 0, function* () {\n          yield db.close();\n          const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n\n          deleteDBRequest.onsuccess = () => {\n            obs.next(true);\n            obs.complete();\n          };\n\n          deleteDBRequest.onerror = error => obs.error(error);\n\n          deleteDBRequest.onblocked = () => {\n            throw new Error(`Unable to delete database because it's blocked`);\n          };\n        })).catch(error => obs.error(error));\n      });\n    }\n    /**\n     * Returns the open cursor event\n     * @param storeName The name of the store to have the entries deleted\n     * @param keyRange The key range which the cursor should be open on\n     */\n\n\n    openCursor(storeName, keyRange) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n\n          request.onsuccess = event => {\n            obs.next(event);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Open a cursor by index filter.\n     * @param storeName The name of the store to query.\n     * @param indexName The index name to filter.\n     * @param keyRange The range value and criteria to apply on the index.\n     */\n\n\n    openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n      const obs = new Subject();\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, reason => {\n          obs.error(reason);\n        });\n        const transaction = createTransaction(db, optionsGenerator(mode, storeName, reason => {\n          obs.error(reason);\n        }, () => {\n          obs.next();\n        }));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openCursor(keyRange);\n\n        request.onsuccess = event => {\n          obs.next(event);\n        };\n      }).catch(reason => obs.error(reason));\n      return obs;\n    }\n    /**\n     * Returns all items by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n\n\n    getAllByIndex(storeName, indexName, keyRange) {\n      const data = [];\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.openCursor(keyRange);\n\n          request.onsuccess = event => {\n            const cursor = event.target.result;\n\n            if (cursor) {\n              data.push(cursor.value);\n              cursor.continue();\n            } else {\n              obs.next(data);\n              obs.complete();\n            }\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns all primary keys by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n\n\n    getAllKeysByIndex(storeName, indexName, keyRange) {\n      const data = [];\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.openKeyCursor(keyRange);\n\n          request.onsuccess = event => {\n            const cursor = event.target.result;\n\n            if (cursor) {\n              data.push({\n                primaryKey: cursor.primaryKey,\n                key: cursor.key\n              });\n              cursor.continue();\n            } else {\n              obs.next(data);\n              obs.complete();\n            }\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n\n\n    count(storeName, keyRange) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.count(keyRange);\n\n          request.onerror = e => obs.error(e);\n\n          request.onsuccess = e => {\n            obs.next(e.target.result);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n\n\n    countByIndex(storeName, indexName, keyRange) {\n      return new Observable(obs => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          validateBeforeTransaction(db, storeName, e => obs.error(e));\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.count(keyRange);\n\n          request.onerror = e => obs.error(e);\n\n          request.onsuccess = e => {\n            obs.next(e.target.result);\n            obs.complete();\n          };\n        }).catch(reason => obs.error(reason));\n      });\n    }\n    /**\n     * Delete the store by name.\n     * @param storeName The name of the store to query\n     */\n\n\n    deleteObjectStore(storeName) {\n      return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n    }\n\n  }\n\n  NgxIndexedDBService.ɵfac = function NgxIndexedDBService_Factory(t) {\n    return new (t || NgxIndexedDBService)(i0.ɵɵinject(CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID));\n  };\n\n  NgxIndexedDBService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxIndexedDBService,\n    factory: NgxIndexedDBService.ɵfac\n  });\n  return NgxIndexedDBService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxIndexedDBModule = /*#__PURE__*/(() => {\n  class NgxIndexedDBModule {\n    static forRoot(dbConfig) {\n      return {\n        ngModule: NgxIndexedDBModule,\n        providers: [NgxIndexedDBService, {\n          provide: CONFIG_TOKEN,\n          useValue: dbConfig\n        }]\n      };\n    }\n\n  }\n\n  NgxIndexedDBModule.ɵfac = function NgxIndexedDBModule_Factory(t) {\n    return new (t || NgxIndexedDBModule)();\n  };\n\n  NgxIndexedDBModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxIndexedDBModule\n  });\n  NgxIndexedDBModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return NgxIndexedDBModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService }; //# sourceMappingURL=ngx-indexed-db.mjs.map","map":null,"metadata":{},"sourceType":"module"}